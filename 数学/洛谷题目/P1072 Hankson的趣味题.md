# Hankson的趣味题 P1072

## 题目描述

# [NOIP2009 提高组] Hankson 的趣味题

## 题目描述


今天在课堂上，老师讲解了如何求两个正整数 $c_1$ 和 $c_2$ 的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 $a_0,a_1,b_0,b_1$，设某未知正整数 $x$ 满足：

1. $x$ 和 $a_0$ 的最大公约数是 $a_1$ ；

2. $x$ 和 $b_0$ 的最小公倍数是 $b_1$ 。

Hankson 的“逆问题”就是求出满足条件的正整数 $x$。但稍加思索之后，他发现这样的 $x$ 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的 $x$ 的个数。请你帮助他编程求解这个问题。

## 输入格式

第一行为一个正整数 $n$，表示有 $n$ 组输入数据。接下来的$n$ 行每行一组输入数据，为四个正整数 $a_0,a_1,b_0,b_1$ ，每两个整数之间用一个空格隔开。输入数据保证 $a_0$ 能被 $a_1$ 整除，$b_1$ 能被 $b_0$ 整除。

## 输出格式

共 $n$ 行。每组输入数据的输出结果占一行，为一个整数。

对于每组数据：若不存在这样的 $x$，请输出 $0$，若存在这样的 $x$，请输出满足条件的 $x$ 的个数；

## 样例 #1

### 样例输入 #1

```
2 
41 1 96 288 
95 1 37 1776
```

### 样例输出 #1

```
6 
2
```

## 提示

**【样例解释】**

第一组输入数据，$x$ 可以是 $9,18,36,72,144,288$，共有 $6$ 个。

第二组输入数据，$x$ 可以是 $48,1776$，共有 $2$ 个。

**【数据范围】**

- 对于 $50\%$ 的数据，保证有 $1\leq a_0,a_1,b_0,b_1 \leq 10000$ 且 $n \leq 100$ 。
- 对于 $100\%$ 的数据，保证有 $1 \leq a_0,a_1,b_0,b_1 \leq 2 \times 10^9$ 且 $n≤2000$ 。

NOIP 2009 提高组 第二题

---

思路:
注意到, $gcd(a,b)=c \Leftrightarrow gcd(\frac a c , \frac b c )=1$
所以 $gcd(x,a_0)=a_1 \Leftrightarrow gcd(\frac x a_1, \frac {a_0}{a_1})=1$
同理 $lcm(x,b_0)=b_1 = \frac {xb_0} {gcd(x,b_0)}  所以,gcd(x,b_0)=\frac {xb_0}{b_1} \Leftrightarrow gcd(\frac{b_1}{b_0},\frac{b_1} x)=1$
然后就可以对 $b_1$ 的所有因子进行枚举求解答案
卡常:这题最恶心的点在于int改为long long 是过不了的 会TLE一个点,所以需要卡常,注意到 $x$ 的范围是 $[1,b_1]$ ,所以 $x$ 的因子个数不会超过 $b_1$ ,所以可以不用开 $O(1)$ 的复杂度,直接暴力枚举 $b_1$ 的所有因子,然后判断是否满足条件即可

```cpp
#include <iostream>
using namespace std;
int a0, a1, b0, b1;
int gcd(int a, int b)
{
   if (b == 0)
        return a;
    return gcd(b, a % b);
}
int main()
{
    int n;
    scanf("%d", &n);
    while (n--)
    {
        int ans = 0;
        scanf("%d%d%d%d", &a0, &a1, &b0, &b1);
        int t = a0 / a1;
        int h = b1 / b0;
        for (int i = 1; i <= b1 / i; i++)
        {
            if (b1 % i == 0)
            {
                int x = i;
                if (x % a1 == 0 && gcd(x / a1, t) == 1 && gcd(h, b1 / x) == 1)
                    ans++;
                int y = b1 / i;
                if (x == y)
                    continue;
                if (y % a1 == 0 && gcd(y / a1, t) == 1 && gcd(h, b1 / y) == 1)
                    ans++;
            }
        }
        printf("%d\n", ans);
    }
    return 0;
}
```