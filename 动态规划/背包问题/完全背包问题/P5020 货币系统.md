# P5020 货币系统

## [NOIP2018 提高组] 货币系统

## 题目描述

在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 $n$ 、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$ 。 

在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$ ，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] \times t[i]$ 的和为 $x$ 。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。例如在货币系统 $n=3$ ,  $a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。 

两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$ ，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 

现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$ ，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$ 。

## 输入格式

输入文件的第一行包含一个整数 $T$，表示数据的组数。

接下来按照如下格式分别给出 $T$ 组数据。 每组数据的第一行包含一个正整数 $n$。接下来一行包含 $n$ 个由空格隔开的正整数 $a[i]$ 。

## 输出格式

输出文件共有 $T$ 行，对于每组数据，输出一行一个正整数，表示所有与 $(n,a)$ 等价的货币系统 $(m,b)$ 中，最小的 $m$ 。

## 样例 #1

### 样例输入 #1

```
2 
4 
3 19 10 6 
5 
11 29 13 19 17
```

### 样例输出 #1

```
2   
5
```

## 提示

在第一组数据中，货币系统 $(2, [3,10])$ 和给出的货币系统 $(n, a)$ 等价，并可以验证不存在 $m < 2$ 的等价的货币系统，因此答案为 $2$ 。 在第二组数据中，可以验证不存在 $m < n$ 的等价的货币系统，因此答案为 $5$ 。 

【数据范围与约定】

![](https://cdn.luogu.com.cn/upload/pic/43160.png)  

对于 $100\%$ 的数据，满足 $1 ≤ T ≤ 20, n,a[i] ≥ 1$ 。

---
思路:
这个很像线性代数中的最大线性无关组问题,对于一个数a,只能被小于它的数表示,所以我们可以先对数组进行排序.然后看前面的数是否可以表示后面的数.然后我们就可以转化为完全背包问题.
对于每个数a[i],如果前面的数可以表示a[i],那么a[i]就可以不用了,否则a[i]必须保留,然后更新f数组.例如:对于 a[3]=10*a[1]+2*a[2](其中a[2]不能被a[1]表示),f[a[3]]+=f[10*a[1]+a[2]], f[10*a[1]+a[2]]又会被f[10*a[1]]更新,总之最后都可以筛掉所有表示的数

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 110, M = 25010;
int n;
int a[N];
int f[M];
int main()
{
    int t;
    cin >> t;
    //货币系统问题
    while (t--)
    {
        cin >> n;
        for (int i = 0; i < n; i++)
            cin >> a[i];
        sort(a, a + n);
        int m = a[n - 1];
        memset(f, 0, sizeof(f));
        f[0] = 1;
        int res = 0;
        for (int i = 0; i < n; i++)
        {
            if (!f[a[i]])
                res++;
            for (int j = a[i]; j <= m; j++)
                f[j] += f[j - a[i]];
        }
        cout << res << endl;
    }
    return 0;
}
```