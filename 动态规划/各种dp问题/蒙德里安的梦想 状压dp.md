求把 N×M 的棋盘分割成若干个 1×2 的长方形，有多少种方案。

例如当 N=2，M=4 时，共有 5 种方案。当 N=2，M=3 时，共有 3 种方案。

如下图所示：

![2411\_1.jpg](https://cdn.acwing.com/media/article/image/2019/01/26/19_4dd1644c20-2411_1.jpg)

#### 输入格式

输入包含多组测试用例。

每组测试用例占一行，包含两个整数 N 和 M。

当输入用例 N=0，M=0 时，表示输入终止，且该用例无需处理。

#### 输出格式

每个测试用例输出一个结果，每个结果占一行。

#### 数据范围

1≤N,M≤11

#### 输入样例：
```
1 2
1 3
1 4
2 2
2 3
2 4
2 11
4 11
0 0
```

#### 输出样例：

```
1
0
1
2
3
5
144
51205
```
## 思路
本题考的是状态压缩dp,可以发现当横向的方格都填好了之后,竖向的方格都是确定的.此时对于每一列放置横向方格的放置方法(第一个方格放置的位置)只与上一列有关.因此可以采用状态压缩dp来求解.
用f[i][j],i表示前i列的,j表示第i列的状态,即第i列的方格的放置方法.
然后需要推算出状态转移方程,即f[i][j]与f[i-1][k]的关系,其中k表示第i-1列的状态.首先,j与k不可以同时放在一个位置上,用"与"操作运算符判断.然后需要判断两列之间有没有奇数个连续的空格,用st数组判断.
st数组我们需要预处理,即判断每一种状态是否合法,合法的状态就是这个状态之间没有奇数个连续的空格.
到时候可以直接调用st[j|k]判断两列之间有没有奇数个连续的空格.

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 12, M = 1 << N;
int n, m;
ll f[N][M];
bool st[M];
int main()
{
    int n, m;
    while (cin >> n >> m, n || m)
    {
        memset(f, 0, sizeof f);
        for (int i = 0; i < (1 << n); i++) // 记录所有的合法方案(即没有奇数个连续的空格)
        {
            st[i] = true;
            int cnt = 0;
            for (int j = 0; j < n; j++)
            {
                if (i >> j & 1) // 遇到有填充的格子了,前面都是空格,停下来记录个数,判断是否为奇数
                {
                    if (cnt & 1) // 连续奇数个空格，不合法
                        st[i] = false;
                    cnt = 0;
                }
                else
                    cnt++;
            }
            if (cnt & 1)
                st[i] = false;
        }
        f[0][0] = 1;
        for (int i = 1; i <= m; i++) // 枚举每一列的状态
        {
            for (int j = 0; j < (1 << n); j++)//对第j列的每一种状态
                for (int k = 0; k < (1 << n); k++)//判断第k列的状态是否可以和第j列连起来
                    if ((j & k) == 0 && st[j | k])//第一个同时为1就会产生冲突,第二个看看两列之间有没有奇数个连续的空格
                        f[i][j] += f[i - 1][k];
        }
        cout << f[m][0] << endl;
    }

    return 0;
}
```
