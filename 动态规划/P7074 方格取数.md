# P7074 方格取数 动态规划

## 题目描述

# [CSP-J2020] 方格取数

## 题目描述

设有 $n \times m$ 的方格图，每个方格中都有一个整数。现有一只小熊，想从图的左上角走到右下角，每一步只能向上、向下或向右走一格，并且不能重复经过已经走过的方格，也不能走出边界。小熊会取走所有经过的方格中的整数，求它能取到的整数之和的最大值。

## 输入格式

第一行有两个整数 $n, m$ 。

接下来 $n$ 行每行 $m$ 个整数，依次代表每个方格中的整数。

## 输出格式

一个整数，表示小熊能取到的整数之和的最大值。

## 样例 #1

### 样例输入 #1

```
3 4
1 -1 3 2
2 -1 4 -1
-2 2 -3 -1
```

### 样例输出 #1

```
9
```

## 样例 #2

### 样例输入 #2

```
2 5
-1 -1 -3 -2 -7
-2 -1 -4 -1 -2
```

### 样例输出 #2

```
-10
```

## 提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/sq4638pa.png)
---

### 样例 2 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/7tfdyabk.png)
---

### 数据规模与约定
- 对于 $20\%$ 的数据， $n, m \le 5$ 。
- 对于 $40\%$ 的数据， $n, m \le 50$ 。
- 对于 $70\%$ 的数据， $n, m \le 300$ 。
- 对于 $100\%$ 的数据， $1 \le n,m \le 10^3$ 。方格中整数的绝对值不超过 $10^4$ 。

---

## 思路
本题可以让两条路同时出发状态为f(i1,j1,i2,j2)表示两条路分别走到(i1,j1)和(i2,j2)的最大值，然后进行状态转移即可。这是朴素做法,优化点在于发现他们坐标和相同,优化为f(k,i1,i2)表示两条路坐标和为k时两条路分别走到(i1,j1)和(i2,j2)的最大值,然后进行状态转移即可。
依据以上分析,可以将情况分为四种,两条路同时往下走;同时往右走;第一条往下走,第二条往右走;第一条往右走,第二条往下走,然后进行状态转移即可。还有一个点就是判重复的点,如果横坐标相同则证明走到了同一个点,此时只加一次权值即可。
最后输出f[n+n][n][n]即可。





---
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 30;
int f[N][N][N]; // 第一维表示和,第二三维表示横坐标
int w[N][N];    // 表示权重
int main()
{
    // 动态规划
    // theNumberOfSquaresIsTaken问题
    int n;
    cin >> n;
    int x, y, z;
    while (cin >> x >> y >> z, x || y || z)
    {
        w[x][y] = z;
    }

    for (int k = 2; k <= n + n; k++)
    {
        for (int i1 = 1; i1 <= n; i1++)
        {
            for (int i2 = 1; i2 <= n; i2++)
            {
                int j1 = k - i1, j2 = k - i2;
                if (j1 >= 1 && j1 <= n && j2 >= 1 && j2 <= n)
                {
                    int t = w[i1][j1];
                    if (i1 != i2)
                        t += w[i2][j2];
                    int &x = f[k][i1][i2];
                    x = max(x, f[k - 1][i1 - 1][i2 - 1] + t); // 第一二个都向下
                    x = max(x, f[k - 1][i1][i2 - 1] + t);     // 第一个向下，第二个向右
                    x = max(x, f[k - 1][i1 - 1][i2] + t);     // 第一个向右，第二个向下
                    x = max(x, f[k - 1][i1][i2] + t);         // 都向右
                }
            }
        }
    }
    cout << f[n + n][n][n] << endl;
    return 0;
}