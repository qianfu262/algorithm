# 单调队列优化dp

## 题目描述
烽火台是重要的军事防御设施，一般建在交通要道或险要处。

一旦有军情发生，则白天用浓烟，晚上有火光传递军情。

在某两个城市之间有 **n** 座烽火台，每个烽火台发出信号都有一定的代价。

为了使情报准确传递，在连续 **m** 个烽火台中至少要有一个发出信号。

现在输入 **n**,**m** 和每个烽火台的代价，请计算在两城市之间准确传递情报所需花费的总代价最少为多少。

输入格式

第一行是两个整数 **n**,**m**，具体含义见题目描述；

第二行 **n** 个整数表示每个烽火台的代价 $a_i$ 。

输出格式

输出仅一个整数，表示最小代价。

数据范围

$1\leq m\leq n \leq 2*10^5$
$0\leq a_i \leq1000$

输入样例：

```
5 3
1 2 5 6 2
```

输出样例：

```
4
```

---

思路:我们设f[i]为点燃1~i中且点燃第i个烽火台的最小代价
f[i]=min(f[j])+w[i],j $\in$ [i-m,i-1],j的范围不能超过m,然后发现我们需要求一段长度为m的固定区间的最小值,可以用单调队列来优化.



```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 200010;
int n, m;
int w[N], q[N];
int f[N];
int main()
{
    // 单调队列优化dp
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> w[i];
    int hh = 0, tt = 0;
    for (int i = 1; i <= n; i++)
    {
        if (q[hh] < i - m)//滑动窗口弹出
            hh++;
        f[i] = f[q[hh]] + w[i];
        while (hh <= tt && f[q[tt]] >= f[i])//弹出队尾的无用元素
            tt--; // 维护单调递增
        q[++tt] = i;
    }
    int res = 1e9;
    for (int i = n - m + 1; i <= n; i++)
        res = min(res, f[i]);
    cout << res << endl;
    return 0;
}
```
