# 斜率优化的dp问题

## 算法思路
本质上是根据状态转移方程,找到变量与未知量,求最小值,利用单调队列维护一个下凸包,求出最优解

## 例题
# 任务安排

## 题目描述

$n$ 个任务排成一个序列在一台机器上等待完成（顺序不得改变），这 $n$ 个任务被分成若干批，每批包含相邻的若干任务。  

从零时刻开始，这些任务被分批加工，第 $i$ 个任务单独完成所需的时间为 $t_i$ 。在每批任务开始前，机器需要启动时间 $s$ ，而完成这批任务所需的时间是各个任务需要时间的总和（同一批任务将在同一时刻完成）。  

每个任务的费用是它的完成时刻乘以一个费用系数 $f_i$ 。请确定一个分组方案，使得总费用最小。

## 输入格式

第一行一个正整数 $n$。  
第二行是一个整数 $s$。

下面 $n$ 行每行有一对数，分别为 $t_i$ 和 $f_i$ ，表示第 $i$ 个任务单独完成所需的时间是 $t_i$ 及其费用系数 $f_i$ 。

## 输出格式

一个数，最小的总费用。

## 样例 #1

### 样例输入 #1

```
5
1
1 3
3 2
4 3
2 3
1 4
```

### 样例输出 #1

```
153
```

## 提示

【数据范围】  
对于 $100\%$ 的数据， $1\le n \le 5000$ ， $0 \le s \le 50$ ， $1\le t_i,f_i \le 100$ 。

【样例解释】   
如果分组方案是 $\{1,2\},\{3\},\{4,5\}$ ，则完成时间分别为 $\{5,5,10,14,14\}$ ，费用 $C=15+10+30+42+56$ ，总费用就是 $153$ 。

---

思路: 对于本题,我们写出状态转移方程
    f[i]=min(f[j]+ti*(ci-cj)+s*(cn-cj))
    我们把这个式子进行变形:f[j]=(ti+s)\*cj+f[i]-ti\*ci-s*cn
    我们发现,这个式子是一个一次函数,ti+s是斜率,而且值固定,这里面唯一的变量就是(x,y)=(cj,f[j]),当这个式子截距最小时,f[i]最小.
    此时就可以引出我们的斜率优化dp了.
    为了让截距尽可能的小,我们需要找到这些点的下凸包,同时根据单调队列优化的思路,及时删去不需要的点,然后在维护的凸包当中找到截距最小的点,也就是相当于在一个斜率单调上升的队列中,找到第一个斜率大于k=ti+s的点,然后更新答案.这一步过程可以用二分来做
    本题具有特殊性质,可以对查询过程进行优化.
    我们发现,问题之中的斜率是单调递增的,而每一个新加的点的横坐标也是单调递增的
    这样我们在对于每一个斜率查询时,可以将队头每一个斜率小于k的点删除,因为这些点永远不会被用到.这样每次查询,直接找队头即可 $\frac{(f_{hh+1}-f_{hh})}{(c_{hh+1}-c_{hh})}<t_i+s$ 弹出队头
    然后我们在插入点时,可以将队尾不在凸包的点进行删除,具体式子是: $\frac{(f_{tt}-f_{tt-1})}{(c_{tt}-c_{tt-1})}>=\frac{(f_i-f_{tt})}{(c_i-c_{tt})}$ 弹出队列



```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 300010;
typedef long long ll;
ll n, s;
ll c[N], t[N];//前缀和
ll f[N];
ll q[N];
int main()
{
    cin >> n >> s;
    for (int i = 1; i <= n; i++)
    {
        cin >> t[i] >> c[i];
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    }
    int hh = 0, tt = 0;
    q[0] = 0;
    for (int i = 1; i <= n; i++)
    {
        while (hh < tt && f[q[hh + 1]] - f[q[hh]] <= (t[i] + s) * (c[q[hh + 1]] - c[q[hh]]))
            hh++;//判断弹出队头的条件
        int j = q[hh];
        f[i] = f[j] - (t[i] + s) * c[j] + t[i] * c[i] + s * c[n];
        while (hh < tt && (f[q[tt]] - f[q[tt - 1]]) * (c[i] - c[q[tt]]) >= (f[i] - f[q[tt]]) * (c[q[tt]] - c[q[tt - 1]]))
            tt--;
        q[++tt] = i;//判断弹出队尾的条件
    }
    cout << f[n] << endl;
    return 0;
}
```

---

## 加强版任务安排
# [SDOI2012] 任务安排

## 题目描述

机器上有 $n$ 个需要处理的任务，它们构成了一个序列。这些任务被标号为 $1$ 到 $n$ ，因此序列的排列为 $1 , 2 , 3 \cdots n$ 。这 $n$ 个任务被分成若干批，每批包含相邻的若干任务。从时刻 $0$ 开始，这些任务被分批加工，第 $i$ 个任务单独完成所需的时间是 $T_i$ 。在每批任务开始前，机器需要启动时间 $s$ ，而完成这批任务所需的时间是各个任务需要时间的总和。

**注意，同一批任务将在同一时刻完成**。每个任务的费用是它的完成时刻乘以一个费用系数 $C_i$ 。

请确定一个分组方案，使得总费用最小。

## 输入格式

第一行一个整数 $n$ 。
第二行一个整数 $s$ 。

接下来 $n$ 行，每行有一对整数，分别为 $T_i$ 和 $C_i$ ，表示第 $i$ 个任务单独完成所需的时间是 $T_i$ 及其费用系数 $C_i$ 。

## 输出格式

一行，一个整数，表示最小的总费用。

## 样例 #1

### 样例输入 #1

```
5
1
1 3
3 2
4 3
2 3
1 4
```

### 样例输出 #1

```
153
```

## 提示

对于 $100\%$ 数据， $1 \le n \le 3 \times 10^5$ ， $1 \le s \le 2^8$ ， $\left| T_i \right| \le 2^8$ ， $0\le C_i \le 2^8$ 。

## 思路

这道题与上一道题不同在于,T允许存在负数,这也就无法保证斜率单调递增,此时我们不能在每一次去队头,而是用二分查找第一个大于斜率的数,不过新加的点的横坐标一定单调递增,依然可以使用上一问中的优化手段.只需要将程序的第一部分进行改写即可.


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 300010;
typedef long long ll;
ll n, s;
ll c[N], t[N]; // 前缀和
ll f[N];
ll q[N];
int main()
{
    cin >> n >> s;
    for (int i = 1; i <= n; i++)
    {
        cin >> t[i] >> c[i];
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    }
    int hh = 0, tt = 0;
    q[0] = 0;
    for (int i = 1; i <= n; i++)
    {
        int l = hh;
        int r = tt;
        // 二分查找
        int j ;
        while (l <= r)
        {
            int mid = (l + r) / 2;
            if (f[q[mid + 1]] - f[q[mid]] > (t[i] + s) * (c[q[mid + 1]] - c[q[mid]]))
            {
                j = q[mid];
                r = mid-1;
            }
            else
                l = mid + 1;
        }
        f[i] = f[j] - (t[i] + s) * c[j] + t[i] * c[i] + s * c[n];
        while (hh < tt && (f[q[tt]] - f[q[tt - 1]]) * (c[i] - c[q[tt]]) >= (f[i] - f[q[tt]]) * (c[q[tt]] - c[q[tt - 1]]))
            tt--;
        q[++tt] = i; // 判断弹出队尾的条件
    }
    cout << f[n] << endl;
    return 0;
}
```


