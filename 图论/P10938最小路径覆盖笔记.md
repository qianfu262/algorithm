# 最小路径覆盖 洛谷P10938
# Vani和Cl2捉迷藏

## 题目描述

Vani 和 cl2 在一片树林里捉迷藏。

这片树林里有 $N$ 座房子，$M$ 条有向道路，组成了一张有向无环图。

树林里的树非常茂密，足以遮挡视线，但是沿着道路望去，却是视野开阔。

如果从房子 $A$ 沿着路走下去能够到达 $B$，那么在 $A$ 和 $B$ 里的人是能够相互望见的。

现在 cl2 要在这 $N$ 座房子里选择 $K$ 座作为藏身点，同时 Vani 也专挑 cl2 作为藏身点的房子进去寻找，为了避免被 Vani 看见，cl2 要求这 $K$ 个藏身点的任意两个之间都没有路径相连。

为了让 Vani 更难找到自己，cl2 想知道最多能选出多少个藏身点。

## 输入格式

输入数据的第一行是两个整数 $N$ 和 $M$ 。

接下来 $M$ 行，每行两个整数 $x,y$，表示一条从 $x$ 到 $y$ 的有向道路。

## 输出格式

输出一个整数，表示最多能选取的藏身点个数。

## 样例 #1

### 样例输入 #1

```
4 4
1 2
3 2
3 4
4 2
```

### 样例输出 #1

```
2
```

## 提示

- 对于 $20\%$ 的数据， $1\leq N\leq 10$ ， $1\leq M\leq 20$ 。
- 对于 $60\%$ 的数据， $1\leq N\leq 100$ ， $1\leq M\leq 1000$ 。
- 对于 $100\%$ 的数据， $1\leq N\leq 200$ ， $1\leq M\leq 30000$ ， $1\leq x,y\leq N$ 。

---
概念: 最小路径点覆盖
针对一个有向无环图,最少的互不相交的路径(点和边都不重复),将所有点覆盖住
如何又跟二分图扯上关系? 拆点思想,将每一条点都拆成两个点,一个出点,一个入点,这样原图中的每一条边都会变成两条边,一条连接出点,一条连接入点. 这样入点和出点分成两部分
定理:一个有向无环图的最小路径点覆盖等于拆点之后(n-该图的最大匹配数),n为原图中点的个数

做法:
先求传递闭包G
然后直接在G上求最小路径点覆盖

根据题面,要求任意两个躲藏点都没有路径相连,
此时,根据最小路径点覆盖的意义,我们有最少的互不相交的路径覆盖所有点,在每一条路径上选择一个点作为躲藏点,这样就能保证任意两个躲藏点没有路径相连,此时,最小路径点覆盖数就是躲藏点的个数



```cpp
#include <bits/stdc++.h>
using namespace std;
// minimalPathOverride
// 最小路径点覆盖
const int N = 210;
int n, m;
int match[N];
bool d[N][N], st[N];

bool find(int x)
{
    for (int i = 1; i <= n; i++)
    {
        if (!st[i] && d[x][i])
        {
            st[i] = true;
            int t = match[i];
            if (t == 0 || find(t))
            {
                match[i] = x;
                return true;
            }
        }
    }
    return false;
}
int main()
{
    scanf("%d%d", &n, &m);
    while (m--)
    {
        int a, b;
        cin >> a >> b;
        d[a][b] = true;
    }

    // 求传递闭包
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++) 
            for (int j = 1; j <= n; j++)
                d[i][j] |= d[i][k] & d[k][j];//如果i能到k,k能到j,那么i也能到j

    int res = 0;
    for (int i = 1; i <= n; i++)
    {
        memset(st, 0, sizeof st);
        if (find(i))
            res++;
    }

    cout << n - res << endl;
    return 0;
}

