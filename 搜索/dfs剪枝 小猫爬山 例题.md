# dfs剪枝 小猫爬山

## dfs剪枝技巧
四种方式:
1.  优化搜索顺序 优先搜索分支较少的的结点,减少搜索量
2.  排除等效冗余 ,排除之前已经搜索到的等效情况
3. 可行性剪枝,提前判断答案是否可行
4. 最优性剪枝,提前判断答案是否是最优解


---
### 题目描述

翰翰和达达饲养了 N只小猫，这天，小猫们要去爬山。\
经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了
翰翰和达达只好花钱让它们坐索道下山。\
索道上的缆车最大承重量为 W，而 N只小猫的重量分别是 $C_1、C_2……C_N$ 。\
当然，每辆缆车上的小猫的重量之和不能超过 W。\
每租用一辆缆车，翰翰和达达就要付 1美元，所以他们想知道，最少需要付多少美元才能把这 N只小猫都运送下山？

#### 输入样例

```
5 1996
1
2
1994
12
29
```

#### 输出样例

```
2
```
---

思路:
这题显然是要我们爆搜每一种情况,找到最小的车辆数量.
第一步优化:将猫的重量从大到小排序,优化搜索顺序,把重的猫放在前面,就可以减少分支数量,因为把重的猫放在前面,后面的猫极有可能放不上去,从而减少了搜索量.
第二步优化:最优性剪枝,如果当前车辆数量已经大于等于已知的最优解,那么就可以直接返回了.



## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
// 小猫下山
// dfs剪枝
const int N = 20;
int n, m;
int w[N];
int sum[N];
int ans = N;
bool cmp(int a, int b)
{
    return a > b;
}
void dfs(int u, int k) // u表示搜到第几只猫了,k表示当时装了多少辆车
{
    if (k >= ans)
        return; // 最优性剪枝
    if (u == n)
    {
        ans = k;
        return;
    }
    for (int i = 0; i < k; i++)
    {
        if (sum[i] + w[u] <= m)
        {
            sum[i] += w[u]; // 装车
            dfs(u + 1, k);
            sum[i] -= w[u]; // 恢复现场
        }
    }
    sum[k] = w[u]; // 新开一辆车
    dfs(u + 1, k + 1);
    sum[k] = 0;
}
int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i++)
        cin >> w[i];
    sort(w, w + n, cmp);//第一步
    dfs(0, 0);
    cout << ans << endl;
    return 0;
}
```